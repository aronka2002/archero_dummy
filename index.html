<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Archero Shooter</title>
    <style>
      canvas {
        will-change: transform;
        transform: translateZ(0);
      }

      body {
        margin: 0;
        padding: 0;
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        font-family: "Arial", sans-serif;
        overflow: hidden;
      }

      #gameContainer {
        position: relative;
        width: 800px;
        height: 600px;
        background: linear-gradient(45deg, #0f3460, #533483);
        border: 3px solid #4a90e2;
        border-radius: 10px;
        overflow: hidden;
        box-shadow: 0 0 30px rgba(74, 144, 226, 0.5);
        width: 90vw;
        height: 75vh;
        max-width: 800px;
        max-height: 600px;
        aspect-ratio: 4 / 3;
      }

      #gameCanvas {
        display: block;
        width: 100%;
        height: 100%;
      }

      #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        color: white;
        font-size: 18px;
        font-weight: bold;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        z-index: 10;
      }

      #gameOver {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 30px;
        border-radius: 15px;
        text-align: center;
        display: none;
        z-index: 20;
        border: 2px solid #4a90e2;
      }

      #restartBtn {
        padding: 10px 20px;
        font-size: 16px;
        background: #4a90e2;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        margin-top: 15px;
        transition: background 0.3s;
      }

      #restartBtn:hover {
        background: #357abd;
      }

      #instructions {
        position: absolute;
        bottom: 10px;
        left: 10px;
        color: rgba(255, 255, 255, 0.8);
        font-size: 12px;
        z-index: 10;
      }

      .health-bar {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        width: 200px;
        height: 20px;
        background: rgba(255, 0, 0, 0.3);
        border: 2px solid #fff;
        border-radius: 10px;
        overflow: hidden;
      }

      .health-fill {
        height: 100%;
        background: linear-gradient(90deg, #ff4444, #ff6666);
        transition: width 0.3s;
        border-radius: 8px;
      }

      #joystickBase {
        position: absolute;
        width: 100px;
        height: 100px;
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid #4a90e2;
        border-radius: 50%;
        display: none;
        z-index: 99;
        pointer-events: none;
      }

      #joystickStick {
        width: 40px;
        height: 40px;
        background: #4a90e2;
        border-radius: 50%;
        position: absolute;
        top: 30px;
        left: 30px;
        pointer-events: none;
      }
    </style>

    <audio id="shootSound" src="shoot.mp3" preload="auto"></audio>
    <audio id="hitSound" src="hit.mp3" preload="auto"></audio>
    <audio id="powerupSound" src="powerup.mp3" preload="auto"></audio>
    <audio id="deathSound" src="death.mp3" preload="auto"></audio>
  </head>
  <body>
    <div id="gameContainer">
      <canvas id="gameCanvas" width="800" height="600"></canvas>

      <div id="ui">
        <div>Level: <span id="level">1</span></div>
        <div>Enemies: <span id="enemies">0</span></div>
        <div>Score: <span id="score">0</span></div>
        <div>High Score: <span id="hscore">0</span></div>
      </div>

      <div class="health-bar">
        <div class="health-fill" id="healthFill"></div>
      </div>

      <div id="instructions">
        WASD or Arrow Keys: Move | Auto-shoot when enemies nearby | Survive and
        level up!
      </div>

      <div id="gameOver">
        <h2>Game Over!</h2>
        <p>Final Score: <span id="finalScore">0</span></p>
        <p>Level Reached: <span id="finalLevel">1</span></p>
        <p>High Score: <span id="highScore">0</span></p>
        <button id="restartBtn">Play Again</button>
      </div>

      <div id="joystickBase">
        <div id="joystickStick"></div>
      </div>
    </div>

    <script>
      const high = localStorage.getItem("archeroHighScore") || 0;
      document.getElementById("hscore").textContent = high;

      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const scoreEl = document.getElementById("score");
      const levelEl = document.getElementById("level");
      const enemiesEl = document.getElementById("enemies");
      const gameOverEl = document.getElementById("gameOver");
      const restartBtn = document.getElementById("restartBtn");
      const healthFill = document.getElementById("healthFill");

      // Game state
      let game = {
        running: true,
        score: 0,
        level: 1,
        enemiesKilled: 0,
        enemiesPerLevel: 10,
      };

      // Player object
      let player = {
        x: 400,
        y: 300,
        width: 30,
        height: 30,
        speed: 5,
        health: 100,
        maxHealth: 100,
        lastShot: 0,
        shootCooldown: 300,
        // Power-up effects
        multiShot: 1,
        bulletSpeed: 8,
        bulletDamage: 1,
        bulletSize: 4,
        piercing: false,
        rapidFire: false,
        shield: false,
        magnetism: false,
        powerUpTimers: {},
      };

      // Game arrays
      let enemies = [];
      let bullets = [];
      let particles = [];
      let powerUps = [];

      // Input handling
      let keys = {};
      window.addEventListener(
        "keydown",
        (e) => (keys[e.key.toLowerCase()] = true)
      );
      window.addEventListener(
        "keyup",
        (e) => (keys[e.key.toLowerCase()] = false)
      );
      const joystickBase = document.getElementById("joystickBase");
      const joystickStick = document.getElementById("joystickStick");

      let joystick = {
        active: false,
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0,
        threshold: 10,
        inputX: 0,
        inputY: 0,
      };

      const gameContainer = document.getElementById("gameContainer");

      gameContainer.addEventListener("touchstart", (e) => {
        const touch = e.touches[0];
        joystick.active = true;

        // Calculate position relative to gameContainer
        const rect = gameContainer.getBoundingClientRect();
        const x = touch.clientX - rect.left;
        const y = touch.clientY - rect.top;

        joystick.startX = x;
        joystick.startY = y;

        const baseX = Math.max(
          0,
          Math.min(gameContainer.clientWidth - 100, x - 50)
        );
        const baseY = Math.max(
          0,
          Math.min(gameContainer.clientHeight - 100, y - 50)
        );
        joystickBase.style.left = `${baseX}px`;
        joystickBase.style.top = `${baseY}px`;
        joystickBase.style.display = "block";
      });

      gameContainer.addEventListener("touchmove", (e) => {
        if (!joystick.active) return;
        const touch = e.touches[0];
        const rect = gameContainer.getBoundingClientRect();
        const x = touch.clientX - rect.left;
        const y = touch.clientY - rect.top;

        const dx = x - joystick.startX;
        const dy = y - joystick.startY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const maxDistance = 40;

        let limitedX = dx;
        let limitedY = dy;
        if (distance > maxDistance) {
          limitedX = (dx / distance) * maxDistance;
          limitedY = (dy / distance) * maxDistance;
        }

        joystickStick.style.transform = `translate(${limitedX}px, ${limitedY}px)`;

        // Normalize input
        joystick.inputX = limitedX / maxDistance;
        joystick.inputY = limitedY / maxDistance;
      });

      gameContainer.addEventListener("touchend", () => {
        joystick.active = false;
        joystick.inputX = 0;
        joystick.inputY = 0;
        joystickStick.style.transform = "translate(0, 0)";
        joystickBase.style.display = "none";
      });

      // Enemy class
      class Enemy {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.width = 25;
          this.height = 25;
          this.speed = 1 + Math.random() * 2;
          this.health = 2 + Math.floor(game.level * 0.5);
          this.maxHealth = this.health;
          this.color = `hsl(${Math.random() * 60}, 70%, 50%)`;
          this.lastDamage = 0;
        }

        update() {
          // Move towards player
          const dx = player.x - this.x;
          const dy = player.y - this.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance > 0) {
            this.x += (dx / distance) * this.speed;
            this.y += (dy / distance) * this.speed;
          }

          // Damage player on contact
          if (distance < 30 && Date.now() - this.lastDamage > 500) {
            player.health -= 10;
            this.lastDamage = Date.now();
            createParticles(player.x, player.y, "#ff4444", 5);
          }
        }

        draw() {
          // Enemy body
          ctx.fillStyle = this.color;
          ctx.fillRect(
            this.x - this.width / 2,
            this.y - this.height / 2,
            this.width,
            this.height
          );

          // Health bar
          if (this.health < this.maxHealth) {
            ctx.fillStyle = "red";
            ctx.fillRect(
              this.x - this.width / 2,
              this.y - this.height / 2 - 8,
              this.width,
              3
            );
            ctx.fillStyle = "green";
            ctx.fillRect(
              this.x - this.width / 2,
              this.y - this.height / 2 - 8,
              (this.health / this.maxHealth) * this.width,
              3
            );
          }

          // Enemy eyes
          ctx.fillStyle = "white";
          ctx.fillRect(this.x - 8, this.y - 8, 4, 4);
          ctx.fillRect(this.x + 4, this.y - 8, 4, 4);
          ctx.fillStyle = "black";
          ctx.fillRect(this.x - 7, this.y - 7, 2, 2);
          ctx.fillRect(this.x + 5, this.y - 7, 2, 2);
        }

        takeDamage(damage) {
          this.health -= damage;
          createParticles(this.x, this.y, this.color, 3);
          return this.health <= 0;
        }
      }

      // PowerUp class
      class PowerUp {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.width = 20;
          this.height = 20;
          this.bobOffset = Math.random() * Math.PI * 2;
          this.lifeTime = 15000; // 15 seconds
          this.spawnTime = Date.now();
          this.collected = false;

          // Power-up types
          const types = [
            {
              type: "multiShot",
              color: "#ff6b6b",
              icon: "▲",
              name: "Multi Shot",
            },
            {
              type: "rapidFire",
              color: "#4ecdc4",
              icon: "⚡",
              name: "Rapid Fire",
            },
            {
              type: "bigBullets",
              color: "#45b7d1",
              icon: "●",
              name: "Big Bullets",
            },
            { type: "piercing", color: "#96ceb4", icon: "→", name: "Piercing" },
            { type: "health", color: "#ffeaa7", icon: "♥", name: "Health" },
            { type: "shield", color: "#a29bfe", icon: "◊", name: "Shield" },
            { type: "speed", color: "#fd79a8", icon: "»", name: "Speed Boost" },
            { type: "magnet", color: "#fdcb6e", icon: "◎", name: "Magnet" },
          ];

          const powerUp = types[Math.floor(Math.random() * types.length)];
          this.type = powerUp.type;
          this.color = powerUp.color;
          this.icon = powerUp.icon;
          this.name = powerUp.name;
        }

        update() {
          // Bobbing animation
          this.y += Math.sin(Date.now() * 0.005 + this.bobOffset) * 0.5;

          // Magnet effect
          if (player.magnetism) {
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < 100) {
              this.x += (dx / distance) * 3;
              this.y += (dy / distance) * 3;
            }
          }

          // Check if expired
          return Date.now() - this.spawnTime > this.lifeTime;
        }

        draw() {
          const pulseScale = 1 + Math.sin(Date.now() * 0.01) * 0.1;
          const size = this.width * pulseScale;

          // Glow effect
          ctx.shadowColor = this.color;
          ctx.shadowBlur = 15;

          // Background circle
          ctx.fillStyle = this.color + "40";
          ctx.beginPath();
          ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
          ctx.fill();

          // Main circle
          ctx.fillStyle = this.color;
          ctx.beginPath();
          ctx.arc(this.x, this.y, size * 0.7, 0, Math.PI * 2);
          ctx.fill();

          // Icon
          ctx.shadowBlur = 0;
          ctx.fillStyle = "white";
          ctx.font = "16px Arial";
          ctx.textAlign = "center";
          ctx.fillText(this.icon, this.x, this.y + 5);

          // Name tooltip when close
          const dx = player.x - this.x;
          const dy = player.y - this.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < 50) {
            ctx.fillStyle = "rgba(0,0,0,0.8)";
            ctx.fillRect(this.x - 30, this.y - 35, 60, 15);
            ctx.fillStyle = "white";
            ctx.font = "10px Arial";
            ctx.fillText(this.name, this.x, this.y - 27);
          }
        }

        collect() {
          if (this.collected) return;
          this.collected = true;

          createParticles(this.x, this.y, this.color, 8);

          switch (this.type) {
            case "multiShot":
              player.multiShot = Math.min(5, player.multiShot + 1);
              break;
            case "rapidFire":
              player.rapidFire = true;
              player.shootCooldown = 150;
              player.powerUpTimers.rapidFire = Date.now() + 10000;
              break;
            case "bigBullets":
              player.bulletSize = Math.min(10, player.bulletSize + 2);
              player.bulletDamage = Math.min(5, player.bulletDamage + 1);
              break;
            case "piercing":
              player.piercing = true;
              player.powerUpTimers.piercing = Date.now() + 12000;
              break;
            case "health":
              player.health = Math.min(player.maxHealth, player.health + 30);
              break;
            case "shield":
              player.shield = true;
              player.powerUpTimers.shield = Date.now() + 8000;
              break;
            case "speed":
              player.speed = Math.min(8, player.speed + 1);
              break;
            case "magnet":
              player.magnetism = true;
              player.powerUpTimers.magnet = Date.now() + 15000;
              break;
          }
        }
      }
      class Bullet {
        constructor(x, y, targetX, targetY) {
          this.x = x;
          this.y = y;
          this.speed = 8;
          this.damage = 1;
          this.size = 4;

          // Calculate direction
          const dx = targetX - x;
          const dy = targetY - y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          this.vx = (dx / distance) * this.speed;
          this.vy = (dy / distance) * this.speed;
        }

        update() {
          this.x += this.vx;
          this.y += this.vy;
          return (
            this.x < 0 ||
            this.x > canvas.width ||
            this.y < 0 ||
            this.y > canvas.height
          );
        }

        draw() {
          ctx.fillStyle = "#4a90e2";
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fill();

          // Bullet trail
          ctx.fillStyle = "rgba(74, 144, 226, 0.3)";
          ctx.beginPath();
          ctx.arc(
            this.x - this.vx,
            this.y - this.vy,
            this.size * 0.7,
            0,
            Math.PI * 2
          );
          ctx.fill();
        }
      }

      // Particle class
      class Particle {
        constructor(x, y, color) {
          this.x = x;
          this.y = y;
          this.vx = (Math.random() - 0.5) * 6;
          this.vy = (Math.random() - 0.5) * 6;
          this.life = 30;
          this.maxLife = 30;
          this.color = color;
          this.size = Math.random() * 3 + 1;
        }

        update() {
          this.x += this.vx;
          this.y += this.vy;
          this.vx *= 0.95;
          this.vy *= 0.95;
          this.life--;
          return this.life <= 0;
        }

        draw() {
          const alpha = this.life / this.maxLife;
          ctx.fillStyle =
            this.color +
            Math.floor(alpha * 255)
              .toString(16)
              .padStart(2, "0");
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size * alpha, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      function createParticles(x, y, color, count) {
        if (window.innerWidth < 768) count = Math.floor(count * 0.3);
        for (let i = 0; i < count; i++) {
          particles.push(new Particle(x, y, color));
        }
      }

      function resizeCanvas() {
        const scale = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();

        canvas.width = rect.width * scale;
        canvas.height = rect.height * scale;

        ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset any existing transform
        ctx.scale(scale, scale);

        // Update player position to stay inside new bounds
        player.x = Math.max(15, Math.min(canvas.width / scale - 15, player.x));
        player.y = Math.max(15, Math.min(canvas.height / scale - 15, player.y));
      }
      window.addEventListener("resize", resizeCanvas);
      window.addEventListener("orientationchange", resizeCanvas);
      resizeCanvas();

      function playSound(id) {
        const sound = document.getElementById(id);
        if (sound) {
          sound.currentTime = 0;
          sound.play();
        }
      }

      function spawnPowerUp(x, y) {
        powerUps.push(new PowerUp(x, y));
      }
      //     let x, y;
      //     const side = Math.floor(Math.random() * 4);

      //     switch(side) {
      //         case 0: x = -25; y = Math.random() * canvas.height; break;
      //         case 1: x = canvas.width + 25; y = Math.random() * canvas.height; break;
      //         case 2: x = Math.random() * canvas.width; y = -25; break;
      //         case 3: x = Math.random() * canvas.width; y = canvas.height + 25; break;
      //     }

      //     enemies.push(new Enemy(x, y));
      // }

      function updatePlayer() {
        // Movement
        let moveX = joystick.inputX || 0;
        let moveY = joystick.inputY || 0;

        if (!joystick.active) {
          if (keys["w"] || keys["arrowup"]) moveY = -1;
          if (keys["s"] || keys["arrowdown"]) moveY = 1;
          if (keys["a"] || keys["arrowleft"]) moveX = -1;
          if (keys["d"] || keys["arrowright"]) moveX = 1;
        }

        player.x += moveX * player.speed;
        player.y += moveY * player.speed;

        // Keep player in bounds
        const boundsX = canvas.width / (window.devicePixelRatio || 1);
        const boundsY = canvas.height / (window.devicePixelRatio || 1);

        player.x = Math.max(15, Math.min(boundsX - 15, player.x));
        player.y = Math.max(15, Math.min(boundsY - 15, player.y));

        // Auto-shoot at nearest enemy with multi-shot
        if (
          enemies.length > 0 &&
          Date.now() - player.lastShot > player.shootCooldown
        ) {
          let nearest = enemies[0];
          let minDist = Infinity;

          enemies.forEach((enemy) => {
            const dist = Math.sqrt(
              (enemy.x - player.x) ** 2 + (enemy.y - player.y) ** 2
            );
            if (dist < minDist) {
              minDist = dist;
              nearest = enemy;
            }
          });

          if (minDist < 200) {
            // Multi-shot implementation
            if (player.multiShot === 1) {
              bullets.push(
                new Bullet(player.x, player.y, nearest.x, nearest.y)
              );
              playSound("shootSound");
            } else {
              const angleSpread = Math.PI / 6; // 30 degrees
              const angleStep = angleSpread / (player.multiShot - 1);
              const startAngle = -angleSpread / 2;

              for (let i = 0; i < player.multiShot; i++) {
                const angle = startAngle + angleStep * i;
                bullets.push(
                  new Bullet(player.x, player.y, nearest.x, nearest.y, angle)
                );
              }
              playSound("shootSound");
            }
            player.lastShot = Date.now();
          }
        }
      }

      function drawPlayer() {
        // Shield effect
        if (player.shield) {
          ctx.strokeStyle = "#a29bfe";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(player.x, player.y, 25, 0, Math.PI * 2);
          ctx.stroke();

          // Pulsing shield
          ctx.strokeStyle = "rgba(162, 155, 254, 0.5)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(
            player.x,
            player.y,
            25 + Math.sin(Date.now() * 0.01) * 3,
            0,
            Math.PI * 2
          );
          ctx.stroke();
        }

        // Player body
        ctx.fillStyle = "#4a90e2";
        ctx.fillRect(player.x - 15, player.y - 15, 30, 30);

        // Speed boost effect
        if (player.speed > 5) {
          ctx.fillStyle = "rgba(253, 121, 168, 0.3)";
          ctx.fillRect(player.x - 18, player.y - 18, 36, 36);
        }

        // Player face
        ctx.fillStyle = "white";
        ctx.fillRect(player.x - 8, player.y - 8, 4, 4);
        ctx.fillRect(player.x + 4, player.y - 8, 4, 4);
        ctx.fillStyle = "black";
        ctx.fillRect(player.x - 7, player.y - 7, 2, 2);
        ctx.fillRect(player.x + 5, player.y - 7, 2, 2);

        // Weapon indicator
        ctx.fillStyle = "#333";
        ctx.fillRect(player.x - 2, player.y + 8, 4, 8);

        // Multi-shot indicator
        if (player.multiShot > 1) {
          ctx.fillStyle = "#ff6b6b";
          ctx.font = "12px Arial";
          ctx.textAlign = "center";
          ctx.fillText(`×${player.multiShot}`, player.x, player.y - 20);
        }
      }

      function updatePowerUpTimers() {
        const now = Date.now();

        // Rapid Fire
        if (
          player.rapidFire &&
          player.powerUpTimers.rapidFire &&
          now > player.powerUpTimers.rapidFire
        ) {
          player.rapidFire = false;
          player.shootCooldown = 300;
          delete player.powerUpTimers.rapidFire;
        }

        // Piercing
        if (
          player.piercing &&
          player.powerUpTimers.piercing &&
          now > player.powerUpTimers.piercing
        ) {
          player.piercing = false;
          delete player.powerUpTimers.piercing;
        }

        // Shield
        if (
          player.shield &&
          player.powerUpTimers.shield &&
          now > player.powerUpTimers.shield
        ) {
          player.shield = false;
          delete player.powerUpTimers.shield;
        }

        // Magnetism
        if (
          player.magnetism &&
          player.powerUpTimers.magnet &&
          now > player.powerUpTimers.magnet
        ) {
          player.magnetism = false;
          delete player.powerUpTimers.magnet;
        }
      }

      function spawnEnemy() {
        const scale = window.devicePixelRatio || 1;
        const width = canvas.width / scale;
        const height = canvas.height / scale;

        let x, y;
        const side = Math.floor(Math.random() * 4);

        switch (side) {
          case 0: // Left
            x = -25;
            y = Math.random() * height;
            break;
          case 1: // Right
            x = width + 25;
            y = Math.random() * height;
            break;
          case 2: // Top
            x = Math.random() * width;
            y = -25;
            break;
          case 3: // Bottom
            x = Math.random() * width;
            y = height + 25;
            break;
        }

        enemies.push(new Enemy(x, y));
      }

      function checkCollisions() {
        // Bullet-enemy collisions
        bullets.forEach((bullet, bulletIndex) => {
          enemies.forEach((enemy, enemyIndex) => {
            // Skip if piercing bullet already hit this enemy
            if (bullet.piercing && bullet.hitEnemies.includes(enemy)) return;

            const dx = bullet.x - enemy.x;
            const dy = bullet.y - enemy.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < 15) {
              if (bullet.piercing) {
                bullet.hitEnemies.push(enemy);
              } else {
                bullets.splice(bulletIndex, 1);
              }

              if (enemy.takeDamage(bullet.damage)) {
                // 10% chance to drop power-up
                if (Math.random() < 0.1) {
                  spawnPowerUp(enemy.x, enemy.y);
                }

                enemies.splice(enemyIndex, 1);
                game.score += 10;
                game.enemiesKilled++;
                createParticles(enemy.x, enemy.y, "#ffff00", 8);
              }
              playSound("hitSound");
            }
          });
        });

        // Player-powerup collisions
        powerUps.forEach((powerUp, index) => {
          const dx = player.x - powerUp.x;
          const dy = player.y - powerUp.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < 25) {
            powerUp.collect();
            playSound("powerupSound");
            powerUps.splice(index, 1);
          }
        });

        // Player-enemy collisions (with shield check)
        enemies.forEach((enemy) => {
          const dx = player.x - enemy.x;
          const dy = player.y - enemy.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < 30 && Date.now() - enemy.lastDamage > 500) {
            if (player.shield) {
              // Shield absorbs damage
              enemy.takeDamage(999); // Kill enemy instantly
              createParticles(enemy.x, enemy.y, "#a29bfe", 8);
            } else {
              player.health -= 10;
              enemy.lastDamage = Date.now();
              createParticles(player.x, player.y, "#ff4444", 5);
            }
          }
        });
      }

      let lastScore = -1,
        lastLevel = -1,
        lastEnemies = -1;
      function updateUI() {
        if (game.score !== lastScore) {
          scoreEl.textContent = game.score;
          lastScore = game.score;
        }
        if (game.level !== lastLevel) {
          levelEl.textContent = game.level;
          lastLevel = game.level;
        }
        if (enemies.length !== lastEnemies) {
          enemiesEl.textContent = enemies.length;
          lastEnemies = enemies.length;
        }

        healthFill.style.width = (player.health / player.maxHealth) * 100 + "%";
      }

      function updateGame() {
        // Update power-up timers
        updatePowerUpTimers();

        // Spawn enemies
        if (enemies.length < 5 + game.level && Math.random() < 0.02) {
          spawnEnemy();
        }

        // Spawn power-ups occasionally
        let powerupcheckcount = window.innerWidth < 768 ? 0.001 : 0.003;
        if (Math.random() < powerupcheckcount) {
          const rect = canvas.getBoundingClientRect();
          const x = Math.random() * (rect.width - 100) + 50;
          const y = Math.random() * (rect.height - 100) + 50;
          spawnPowerUp(x, y);
        }

        // Level progression
        if (game.enemiesKilled >= game.enemiesPerLevel) {
          game.level++;
          game.enemiesKilled = 0;
          game.enemiesPerLevel = Math.floor(10 + game.level * 2);
          player.health = Math.min(player.maxHealth, player.health + 20);
          createParticles(player.x, player.y, "#00ff00", 10);

          // Guaranteed power-up on level up
          const offsetX = (Math.random() - 0.5) * 100;
          const offsetY = (Math.random() - 0.5) * 100;

          const rect = canvas.getBoundingClientRect();
          const scaleX = canvas.width / rect.width;
          const scaleY = canvas.height / rect.height;

          const newX = Math.max(
            20,
            Math.min(canvas.width - 20, player.x + offsetX * scaleX)
          );
          const newY = Math.max(
            20,
            Math.min(canvas.height - 20, player.y + offsetY * scaleY)
          );

          spawnPowerUp(newX, newY);
        }

        // Update UI
        // scoreEl.textContent = game.score;
        // levelEl.textContent = game.level;
        // enemiesEl.textContent = enemies.length;
        // healthFill.style.width = (player.health / player.maxHealth) * 100 + "%";
        updateUI();

        // Check game over
        if (player.health <= 0) {
          gameOver();
        }
      }

      let frameCount = 0;
      function gameLoop() {
        if (!game.running) return;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        updatePlayer();
        updateGame();

        // Only update heavy stuff every 2 frames on mobile
        if (frameCount % 2 === 0 && window.innerWidth < 768) {
          enemies.forEach((enemy) => enemy.update());
          bullets = bullets.filter((bullet) => !bullet.update());
          particles = particles.filter((p) => !p.update());
        } else {
          enemies.forEach((enemy) => enemy.update());
          bullets = bullets.filter((bullet) => !bullet.update());
          particles = particles.filter((p) => !p.update());
        }

        checkCollisions();
        drawPlayer();
        enemies.forEach((enemy) => enemy.draw());
        bullets.forEach((bullet) => bullet.draw());
        powerUps.forEach((powerUp) => powerUp.draw());
        particles.forEach((particle) => particle.draw());

        frameCount++;
        requestAnimationFrame(gameLoop);
      }

      function gameOver() {
        game.running = false;
        document.getElementById("finalScore").textContent = game.score;
        document.getElementById("finalLevel").textContent = game.level;

        // Check and save high score
        const high = localStorage.getItem("archeroHighScore") || 0;
        if (game.score > high) {
          localStorage.setItem("archeroHighScore", game.score);
        }
        document.getElementById("highScore").textContent =
          localStorage.getItem("archeroHighScore");

        gameOverEl.style.display = "block";
        playSound("deathSound");
      }

      function restartGame() {
        game = {
          running: true,
          score: 0,
          level: 1,
          enemiesKilled: 0,
          enemiesPerLevel: 10,
        };

        player = {
          x: 400,
          y: 300,
          width: 30,
          height: 30,
          speed: 5,
          health: 100,
          maxHealth: 100,
          lastShot: 0,
          shootCooldown: 300,
          // Reset power-up effects
          multiShot: 1,
          bulletSpeed: 8,
          bulletDamage: 1,
          bulletSize: 4,
          piercing: false,
          rapidFire: false,
          shield: false,
          magnetism: false,
          powerUpTimers: {},
        };

        enemies = [];
        bullets = [];
        particles = [];
        powerUps = [];

        gameOverEl.style.display = "none";
        gameLoop();
      }

      // Event listeners
      restartBtn.addEventListener("click", restartGame);

      // Start game
      gameLoop();

      window.onload = () => {
        if (/Mobi|Android/i.test(navigator.userAgent)) {
          joystickBase.style.display = "block";
        }
      };

      let audioUnlocked = false;

      function unlockAudio() {
        if (audioUnlocked) return;
        audioUnlocked = true;

        const ids = ["shootSound", "hitSound", "powerupSound", "deathSound"];

        ids.forEach((id) => {
          const audio = document.getElementById(id);
          if (audio) {
            try {
              // Create a silent unlock by playing, then pausing
              const playPromise = audio.play();
              if (playPromise !== undefined) {
                playPromise
                  .then(() => {
                    audio.pause();
                    audio.currentTime = 0;
                  })
                  .catch(() => {
                    // Fail silently
                  });
              }
            } catch (e) {
              // Fail silently
            }
          }
        });
      }

      // Trigger unlock on first interaction
      ["mousedown", "touchstart", "keydown"].forEach((event) => {
        window.addEventListener(event, unlockAudio, { once: true });
      });
    </script>
  </body>
</html>
